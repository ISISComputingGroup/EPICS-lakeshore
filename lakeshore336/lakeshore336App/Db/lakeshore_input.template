
# Template to provide the records required for an input. 
# This makes use of the macros required by lakeshore336.template
# but also requires macros to specify the input channel and index.
# The index is to provide a way for the developer to use a different
# channel naming scheme.
#
# For some commands, I hard coded the last part of the record names into 
# the protocol file. This seems the easiest way to deal with commands
# will lots of params returned back, and avoid problematic long INP fields. 
# For the ZONE commands I used waveforms and subarrays, but that is not as simple.
#
# Macros:
# INPUT - A to D
# INDEX - Index to use for the input channel PV name and DESC (eg. 0 to 3)
# DISABLE - PV name to use for SDIS

##
## Alarm summary record for input
## This summarizes the software limits on the temperature readings,
## the alarm status reading from the controller and the input reading status.
##
record(calc, "$(P):ALARM$(INDEX)_SUMMARY_CALC") {
  field(INPA, "$(P):TEMP$(INDEX) CP MS")
  field(INPB, "$(P):ALARM$(INDEX):HIGH CP MS")
  field(INPC, "$(P):ALARM$(INDEX):LOW CP MS")
  field(INPD, "$(P):RDGST$(INDEX) CP MS")
  field(CALC, "A")
  field(FLNK, "$(P):ALARM$(INDEX)_SUMMARY_CALC2")
  field(SDIS, "$(DISABLE)")  
}

record(calcout, "$(P):ALARM$(INDEX)_SUMMARY_CALC2") {
  field(INPA, "$(P):ALARM$(INDEX)_SUMMARY_CALC.STAT")
  field(CALC, "A!=0?1:0")
  field(DOPT, "Use CALC")
  field(OOPT, "Every Time")
  field(OUT, "$(P):ALARM$(INDEX)_SUMMARY PP")
}

record(bi, "$(P):ALARM$(INDEX)_SUMMARY") {
  field(ZNAM, "No Alarm")
  field(ONAM, "Alarm")
  field(OSV, "MAJOR")
  field(PINI, "YES")
  field(VAL, "0")  
}

##
## If we disable polling this input, disable the alarm
##
record(calcout, "$(P):ALARM$(INDEX)_SUMMARY_DISABLE") {
  field(INPA, "$(DISABLE) CP")
  field(CALC, "A==1?0:1")
  field(DOPT, "Use CALC")
  field(OOPT, "When Zero")
  field(OUT, "$(P):ALARM$(INDEX)_SUMMARY.VAL PP")
}
	

## 
## Read the temperature on channel $(INDEX) in Kelvin.
## In vendor code this was:
##  record(ai, "$(P):KRDG$(INDEX)")
record(ai, "$(P):TEMP$(INDEX)") {
  field(DTYP, "stream")
  field(SDIS, "$(DISABLE)")
  field(DESC, "Channel $(INDEX) Temperature")
  field(INP, "@ls336.proto getKRDG($(INPUT)) $(PORT) $(ADDR)")
  field(SCAN, "$(TEMPSCAN) second")
  field(PREC, "3")
  field(EGU, "K")
  field(HHSV,"MAJOR")
  field(HSV, "MINOR")
  field(LSV, "MINOR")
  field(LLSV,"MAJOR")
  field(HYST,"1.0")
  field(HIHI,"1000")
  field(HIGH,"1000")
  field(LOW,"-1")
  field(LOLO,"-1")  
}

## 
## Read the raw voltage on channel $(INDEX).
## In vendor code this was:
## record(ai, "$(P):SRDG$(INDEX)")
record(ai, "$(P):RAW_VOLT$(INDEX)") {
  field(DTYP, "stream")
  field(SDIS, "$(DISABLE)")
  field(INP, "@ls336.proto getSRDG($(INPUT)) $(PORT) $(ADDR)")
  field(SCAN, "$(TEMPSCAN) second")
  field(PREC, "3")
  field(EGU, "V")
  field(ADEL, "$(ADEL=1)")
  field(MDEL, "$(MDEL=0)")
}

##
## Set sensor $(INDEX) name 
## In vendor code this was:
## record(stringout, "$(P):INNAME_S$(INDEX)")
record(stringout, "$(P):INPUT$(INDEX):NAME:SP") {
  field(DESC, "Set Input $(INDEX) Name")
  field(DTYP, "stream")
  field(SDIS, "$(P):DISABLE")
  field(OUT, "@ls336.proto setINNAME($(INPUT)) $(PORT) $(ADDR)")
  field(FLNK, "$(P):INNAME$(INDEX).PROC CA")
}

## 
## Read input sensor $(INDEX) name
## In vendor code this was:
## record(stringin, "$(P):INNAME$(INDEX)")
record(stringin, "$(P):INPUT$(INDEX):NAME") {
  field(DESC, "Read Input $(INDEX) Name")
  field(DTYP, "stream")
  field(SDIS, "$(P):DISABLE")
  field(INP, "@ls336.proto getINNAME($(INPUT)) $(PORT) $(ADDR)")
  field(PINI, "YES")
  field(SCAN, "Passive")
}
alias("$(P):INPUT$(INDEX):NAME", "$(P):INPUT$(INDEX):NAME:SP:RBV")

##
## Read the high alarm status for input $(INDEX).
## This also populates ALARM$(INDEX):LOW
## In vendor code this was:
## record(bi, "$(P):ALARM$(INDEX)_HIGH")
record(bi, "$(P):ALARM$(INDEX):HIGH") {
  field(DESC, "High Alarm Status")
  field(DTYP, "stream")
  field(SDIS, "$(DISABLE)")
  field(INP, "@ls336.proto getALARMST($(INPUT),$(P):ALARM$(INDEX):LOW) $(PORT) $(ADDR)")
  field(SCAN, "$(SCAN) second")
  field(ZNAM, "Off")
  field(ONAM, "On")
  field(OSV, "MAJOR")
}

##
## Read the low alarm status for input $(INDEX)
## In vendor code this was:
## record(bi, "$(P):ALARM$(INDEX)_LOW")
record(bi, "$(P):ALARM$(INDEX):LOW") {
  field(DESC, "Low Alarm Status")
  field(DTYP, "Soft Channel")	   
  field(ZNAM, "Off")
  field(ONAM, "On")
  field(OSV, "MAJOR")
}

##
## Read the alarm parameters.
## NOTE: reads values into the inputs of a CALC record 
## In vendor code this was:
## record(bi, "$(P):ALARM$(INDEX)")
record(bi, "$(P):ALARM$(INDEX):SP:RBV_DO") {
  field(DESC, "Read Alarm Params")
  field(DTYP, "stream")
  field(SDIS, "$(DISABLE)")
  field(INP, "@ls336.proto getALARM($(INPUT),$(P):ALARM$(INDEX):SP:RBV_BUFF) $(PORT) $(ADDR)")
  field(SCAN, "$(SCAN) second")
}

record(calc, "$(P):ALARM$(INDEX):SP:RBV_BUFF") {
  field(CALC, "0")
}

##
## Read the rest of the alarm params.
## In vendor code this was:
## record(bi, "$(P):ALARM$(INDEX)_ONOFF")
record(bi, "$(P):ALARM$(INDEX):ON:SP:RBV") {
  field(DESC, "Alarm Enabled")
  field(INP, "$(P):ALARM$(INDEX):SP:RBV_BUFF.A CP")
  field(ZNAM, "Disabled")
  field(ONAM, "Enabled")
}
## In vendor code this was:
## record(ai, "$(P):ALARM$(INDEX)_HIGHVAL")
record(ai, "$(P):ALARM$(INDEX):HIVAL:SP:RBV") {
  field(DESC, "Alarm High Value")
  field(INP, "$(P):ALARM$(INDEX):SP:RBV_BUFF.B CP")
  field(EGU, "K")
}
## In vendor code this was:
## record(ai, "$(P):ALARM$(INDEX)_LOWVAL")
record(ai, "$(P):ALARM$(INDEX):LOVAL:SP:RBV") {
  field(DESC, "Alarm Low Value")
  field(INP, "$(P):ALARM$(INDEX):SP:RBV_BUFF.C CP")
  field(EGU, "K")
}
## In vendor code this was:
## record(ai, "$(P):ALARM$(INDEX)_DB")
record(ai, "$(P):ALARM$(INDEX):DEADBAND:SP:RBV") {
  field(DESC, "Alarm Deadband")
  field(INP, "$(P):ALARM$(INDEX):SP:RBV_BUFF.D CP")
  field(EGU, "K")
}
## In vendor code this was:
## record(bi, "$(P):ALARM$(INDEX)_LE")
record(bi, "$(P):ALARM$(INDEX):LATCHED:SP:RBV") {
  field(DESC, "Alarm Latch Enable")
  field(INP, "$(P):ALARM$(INDEX):SP:RBV_BUFF.E CP")
  field(ZNAM, "Non Latching")
  field(ONAM, "Latching")
}
## In vendor code this was:
## record(bi, "$(P):ALARM$(INDEX)_AU")
record(bi, "$(P):ALARM$(INDEX):AUDIBLE:SP:RBV") {
  field(DESC, "Alarm Audible")
  field(INP, "$(P):ALARM$(INDEX):SP:RBV_BUFF.F CP")
  field(ZNAM, "Quiet")
  field(ONAM, "Audible")
}
## In vendor code this was:
## record(bi, "$(P):ALARM$(INDEX)_VIS")
record(bi, "$(P):ALARM$(INDEX):VISIBLE:SP:RBV") {
  field(DESC, "Alarm Visible")
  field(INP, "$(P):ALARM$(INDEX):SP:RBV_BUFF.G CP")
  field(ZNAM, "Non Visible")
  field(ONAM, "Visible")
}


## ISIS: This may need to change to an mbbiDirect
## Read the input reading status
##
record(mbbi, "$(P):RDGST$(INDEX)") {
  field(DTYP, "stream")
  field(SDIS, "$(DISABLE)")
  field(ZRST, "Valid")
  field(ZRVL, "0")
  field(ONST, "Invalid")
  field(ONVL, "1")
  field(TWST, "Temp Under")
  field(TWVL, "16")
  field(THST, "Temp Over")
  field(THVL, "32")
  field(FRST, "Sensor Zero")
  field(FRVL, "64")
  field(FVST, "Sensor Over")
  field(FVVL, "128")
  field(ONSV, "MAJOR")
  field(TWSV, "MAJOR")
  field(THSV, "MAJOR")
  field(FRSV, "MAJOR")
  field(FVSV, "MAJOR")
  field(SCAN, "$(SCAN) second")  
  field(INP, "@ls336.proto getRDGST($(INPUT)) $(PORT) $(ADDR)")
}

##
## Read the input curve number
##
record(longin, "$(P):INCRV$(INDEX)") {
  field(DTYP, "stream")
  field(SDIS, "$(DISABLE)")
  field(SCAN, "$(SCAN) second")  
  field(INP, "@ls336.proto getINCRV($(INPUT)) $(PORT) $(ADDR)")
  field(FLNK, "$(P):INCRV$(INDEX)_HEAD")
}

##
## Read the input curve header.
## 
record(bi, "$(P):INCRV$(INDEX)_HEAD") {
  field(DESC, "Read Input Curve Header Params")
  field(DTYP, "stream")
  field(SDIS, "$(DISABLE)")
  field(INP, "@ls336.proto getCRVHDR($(P):INCRV$(INDEX),N,SN,F,LIM,C) $(PORT) $(ADDR)")
}

##
## Read the rest of the input curve header.
##
record(stringin, "$(P):INCRV$(INDEX)_N") {
  field(DESC, "Curve Name")
}

record(stringin, "$(P):INCRV$(INDEX)_SN") {
  field(DESC, "Curve Serial Number")
}

record(mbbi, "$(P):INCRV$(INDEX)_F") {
  field(DESC, "Curve Data Format")
  field(ZRVL, "0")
  field(ZRST, "Unknown")
  field(ONVL, "1")
  field(ONST, "mV/K")
  field(TWVL, "2")
  field(TWST, "V/K")
  field(THVL, "3")
  field(THST, "Ohm/K")
  field(FRVL, "4")
  field(FRST, "log Ohm/K")
}

record(ai, "$(P):INCRV$(INDEX)_LIM") {
  field(DESC, "Curve Temperature Limit")
  field(EGU, "K")
  field(PREC, "3")
}

record(mbbi, "$(P):INCRV$(INDEX)_C") {
  field(DESC, "Curve Temperature Coefficient")
  field(ZRVL, "0")
  field(ZRST, "Unknown")
  field(ONVL, "1")
  field(ONST, "Negative")
  field(TWVL, "2")
  field(TWST, "Positive")
}


## Isabella: try to remove hard-coding from protocol
## Read the input type information.
## NOTE: the last part of the record name is hard coded into protocol file. 
##
record(bi, "$(P):INTYPE$(INDEX)") {
  field(DESC, "Read Input Type Params")
  field(DTYP, "stream")
  field(SDIS, "$(DISABLE)")
  field(INP, "@ls336.proto getINTYPE($(INPUT),$(P):INTYPE$(INDEX)) $(PORT) $(ADDR)")
  field(SCAN, "$(SCAN) second")
}

##
## Read the rest of the input type params.
## NOTE: the last part of the record names are hard coded into protocol file. 
##
record(mbbi, "$(P):INTYPE$(INDEX)_S") {
  field(DESC, "Sensor Type")
  field(ZRST, "Disabled")
  field(ZRVL, "0")
  field(ONST, "Diode")
  field(ONVL, "1")
  field(TWST, "Platinum RTD")
  field(TWVL, "2")
  field(THST, "NTC RTD")
  field(THVL, "3")
  field(FRST, "Thermocouple")
  field(FRVL, "4")
  field(FVST, "Capacitance")
  field(FVVL, "5")
}
record(bi, "$(P):INTYPE$(INDEX)_AR") {
  field(DESC, "Auto Range")
  field(ZNAM, "Off")
  field(ONAM, "On")
}
record(mbbi, "$(P):INTYPE$(INDEX)_R") {
  field(DESC, "Range")
  field(ZRST, "10 Ohm / 2.5V / 50mV")
  field(ZRVL, "0")
  field(ONST, "30 Ohm / 10V")
  field(ONVL, "1")
  field(TWST, "100 Ohm")
  field(TWVL, "2")
  field(THST, "300 Ohm")
  field(THVL, "3")
  field(FRST, "1 KOhm")
  field(FRVL, "4")
  field(FVST, "3 KOhm")
  field(FVVL, "5")
  field(SXST, "10 KOhm")
  field(SXVL, "6")
  field(SVST, "30 KOhm")
  field(SVVL, "7")
  field(EIST, "100 KOhm")
  field(EIVL, "8")
}
record(bi, "$(P):INTYPE$(INDEX)_C") {
  field(DESC, "Compensation")
  field(ZNAM, "Off")
  field(ONAM, "On")
}
record(mbbi, "$(P):INTYPE$(INDEX)_U") {
  field(DESC, "Units")
  field(ZRST, "None")
  field(ZRVL, "0")
  field(ONST, "Kelvin")
  field(ONVL, "1")
  field(TWST, "Celcius")
  field(TWVL, "2")
  field(THST, "Sensor")
  field(THVL, "3")
}


